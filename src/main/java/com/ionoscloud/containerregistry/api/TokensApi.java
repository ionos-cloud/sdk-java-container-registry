/*
 * Container Registry service
 * Container Registry service enables IONOS clients to manage docker and OCI compliant registries for use by their managed Kubernetes clusters. Use a Container Registry to ensure you have a privately accessed registry to efficiently support image pulls.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ionoscloud.containerregistry.api;

import com.ionoscloud.containerregistry.ApiCallback;
import com.ionoscloud.containerregistry.ApiClient;
import com.ionoscloud.containerregistry.ApiException;
import com.ionoscloud.containerregistry.ApiResponse;
import com.ionoscloud.containerregistry.Configuration;
import com.ionoscloud.containerregistry.Pair;
import com.ionoscloud.containerregistry.ProgressRequestBody;
import com.ionoscloud.containerregistry.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.ionoscloud.containerregistry.model.ApiErrorResponse;
import com.ionoscloud.containerregistry.model.PatchTokenInput;
import com.ionoscloud.containerregistry.model.PostTokenInput;
import com.ionoscloud.containerregistry.model.PostTokenOutput;
import com.ionoscloud.containerregistry.model.PutTokenInput;
import com.ionoscloud.containerregistry.model.PutTokenOutput;
import com.ionoscloud.containerregistry.model.TokenResponse;
import com.ionoscloud.containerregistry.model.TokensResponse;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TokensApi {
    private ApiClient localVarApiClient;

    public TokensApi() {
        this(Configuration.getDefaultApiClient());
    }

    public TokensApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for registriesTokensDelete
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensDeleteCall(UUID registryId, UUID tokenId, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/tokens/{tokenId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()))
            .replaceAll("\\{" + "tokenId" + "\\}", localVarApiClient.escapeString(tokenId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesTokensDeleteValidateBeforeCall(UUID registryId, UUID tokenId, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesTokensDelete(Async)");
        }
        
        // verify the required parameter 'tokenId' is set
        if (tokenId == null) {
            throw new ApiException("Missing the required parameter 'tokenId' when calling registriesTokensDelete(Async)");
        }
        

        okhttp3.Call localVarCall = registriesTokensDeleteCall(registryId, tokenId, callback);
        return localVarCall;

    }

    /**
     * Delete token
     * 
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public void registriesTokensDelete(UUID registryId, UUID tokenId) throws ApiException {
        registriesTokensDeleteWithHttpInfo(registryId, tokenId);
    }

    /**
     * Delete token
     * 
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * 
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> registriesTokensDeleteWithHttpInfo(UUID registryId, UUID tokenId) throws ApiException {
        okhttp3.Call localVarCall = registriesTokensDeleteValidateBeforeCall(registryId, tokenId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete token (asynchronously)
     * 
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensDeleteAsync(UUID registryId, UUID tokenId, final ApiCallback<Void> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesTokensDeleteValidateBeforeCall(registryId, tokenId, callback);
        localVarApiClient.executeAsync(localVarCall, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesTokensFindById
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensFindByIdCall(UUID registryId, UUID tokenId, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/tokens/{tokenId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()))
            .replaceAll("\\{" + "tokenId" + "\\}", localVarApiClient.escapeString(tokenId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesTokensFindByIdValidateBeforeCall(UUID registryId, UUID tokenId, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesTokensFindById(Async)");
        }
        
        // verify the required parameter 'tokenId' is set
        if (tokenId == null) {
            throw new ApiException("Missing the required parameter 'tokenId' when calling registriesTokensFindById(Async)");
        }
        

        okhttp3.Call localVarCall = registriesTokensFindByIdCall(registryId, tokenId, callback);
        return localVarCall;

    }

    /**
     * Get token information
     * Gets all information for a specific token used to access a container registry
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * 
     * @return TokenResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public TokenResponse registriesTokensFindById(UUID registryId, UUID tokenId) throws ApiException {
        ApiResponse<TokenResponse> localVarResp = registriesTokensFindByIdWithHttpInfo(registryId, tokenId);
        return localVarResp.getData();
    }

    /**
     * Get token information
     * Gets all information for a specific token used to access a container registry
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * 
     * @return ApiResponse&lt;TokenResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TokenResponse> registriesTokensFindByIdWithHttpInfo(UUID registryId, UUID tokenId) throws ApiException {
        okhttp3.Call localVarCall = registriesTokensFindByIdValidateBeforeCall(registryId, tokenId, null);
        Type localVarReturnType = new TypeToken<TokenResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get token information (asynchronously)
     * Gets all information for a specific token used to access a container registry
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensFindByIdAsync(UUID registryId, UUID tokenId, final ApiCallback<TokenResponse> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesTokensFindByIdValidateBeforeCall(registryId, tokenId, callback);
        Type localVarReturnType = new TypeToken<TokenResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesTokensGet
     * @param registryId The unique ID of the registry (required)
     * @param offset The first element (from the complete list of the elements) to include in the response (used together with limit for pagination) (optional, default to 0)
     * @param limit The maximum number of elements to return (used together with offset for pagination) (optional, default to 100)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensGetCall(UUID registryId, String offset, String limit,  String orderBy, Integer maxResults, Map<String, String> filters,final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/tokens"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }
        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }
        if (orderBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderBy", orderBy));
        }
        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }
        if (filters != null) {
            filters.forEach((key, value) -> {
                localVarQueryParams.add(new Pair(String.format("filter.%s", key), value));
            });
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesTokensGetValidateBeforeCall(UUID registryId, String offset, String limit,  String orderBy, Integer maxResults , Map<String, String> filters,final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesTokensGet(Async)");
        }
        

        okhttp3.Call localVarCall = registriesTokensGetCall(registryId, offset, limit,  orderBy, maxResults, filters,callback);
        return localVarCall;

    }

    /**
     * List all tokens for the container registry
     * 
     * @param registryId The unique ID of the registry (required)
     * @param offset The first element (from the complete list of the elements) to include in the response (used together with limit for pagination) (optional, default to 0)
     * @param limit The maximum number of elements to return (used together with offset for pagination) (optional, default to 100)
     * @param orderBy - Sorts the results alphanumerically in ascending order based on the specified property.
     * @param maxResults - Limits the number of results returned.
     * @param filters - Filters query parameters limit results to those containing a matching value for a specific property.
     * @return TokensResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public TokensResponse registriesTokensGet(UUID registryId, String offset, String limit,  String orderBy, Integer maxResults, Map<String, String> filters) throws ApiException {
        ApiResponse<TokensResponse> localVarResp = registriesTokensGetWithHttpInfo(registryId, offset, limit, orderBy, maxResults, filters);
        return localVarResp.getData();
    }

    /**
     * List all tokens for the container registry
     * 
     * @param registryId The unique ID of the registry (required)
     * @param offset The first element (from the complete list of the elements) to include in the response (used together with limit for pagination) (optional, default to 0)
     * @param limit The maximum number of elements to return (used together with offset for pagination) (optional, default to 100)
     * @param orderBy - Sorts the results alphanumerically in ascending order based on the specified property.
     * @param maxResults - Limits the number of results returned.
     * @param filters - Filters query parameters limit results to those containing a matching value for a specific property.
     * @return ApiResponse&lt;TokensResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TokensResponse> registriesTokensGetWithHttpInfo(UUID registryId, String offset, String limit, String orderBy, Integer maxResults, Map<String, String> filters) throws ApiException {
        okhttp3.Call localVarCall = registriesTokensGetValidateBeforeCall(registryId, offset, limit,  orderBy, maxResults, filters, null);
        Type localVarReturnType = new TypeToken<TokensResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all tokens for the container registry (asynchronously)
     * 
     * @param registryId The unique ID of the registry (required)
     * @param offset The first element (from the complete list of the elements) to include in the response (used together with limit for pagination) (optional, default to 0)
     * @param limit The maximum number of elements to return (used together with offset for pagination) (optional, default to 100)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensGetAsync(UUID registryId, String offset, String limit, String orderBy, Integer maxResults, Map<String, String> filters,final ApiCallback<TokensResponse> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesTokensGetValidateBeforeCall(registryId, offset, limit,  orderBy, maxResults, filters, callback);
        Type localVarReturnType = new TypeToken<TokensResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesTokensPatch
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param patchTokenInput  (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensPatchCall(UUID registryId, UUID tokenId, PatchTokenInput patchTokenInput, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = patchTokenInput;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/tokens/{tokenId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()))
            .replaceAll("\\{" + "tokenId" + "\\}", localVarApiClient.escapeString(tokenId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesTokensPatchValidateBeforeCall(UUID registryId, UUID tokenId, PatchTokenInput patchTokenInput, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesTokensPatch(Async)");
        }
        
        // verify the required parameter 'tokenId' is set
        if (tokenId == null) {
            throw new ApiException("Missing the required parameter 'tokenId' when calling registriesTokensPatch(Async)");
        }
        
        // verify the required parameter 'patchTokenInput' is set
        if (patchTokenInput == null) {
            throw new ApiException("Missing the required parameter 'patchTokenInput' when calling registriesTokensPatch(Async)");
        }
        

        okhttp3.Call localVarCall = registriesTokensPatchCall(registryId, tokenId, patchTokenInput, callback);
        return localVarCall;

    }

    /**
     * Update token
     * Update token properties, for example: - change status to &#39;enabled&#39; or &#39;disabled&#39; - change expiry date
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param patchTokenInput  (required)
     * 
     * @return TokenResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public TokenResponse registriesTokensPatch(UUID registryId, UUID tokenId, PatchTokenInput patchTokenInput) throws ApiException {
        ApiResponse<TokenResponse> localVarResp = registriesTokensPatchWithHttpInfo(registryId, tokenId, patchTokenInput);
        return localVarResp.getData();
    }

    /**
     * Update token
     * Update token properties, for example: - change status to &#39;enabled&#39; or &#39;disabled&#39; - change expiry date
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param patchTokenInput  (required)
     * 
     * @return ApiResponse&lt;TokenResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TokenResponse> registriesTokensPatchWithHttpInfo(UUID registryId, UUID tokenId, PatchTokenInput patchTokenInput) throws ApiException {
        okhttp3.Call localVarCall = registriesTokensPatchValidateBeforeCall(registryId, tokenId, patchTokenInput, null);
        Type localVarReturnType = new TypeToken<TokenResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update token (asynchronously)
     * Update token properties, for example: - change status to &#39;enabled&#39; or &#39;disabled&#39; - change expiry date
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param patchTokenInput  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensPatchAsync(UUID registryId, UUID tokenId, PatchTokenInput patchTokenInput, final ApiCallback<TokenResponse> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesTokensPatchValidateBeforeCall(registryId, tokenId, patchTokenInput, callback);
        Type localVarReturnType = new TypeToken<TokenResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesTokensPost
     * @param registryId The unique ID of the registry (required)
     * @param postTokenInput  (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensPostCall(UUID registryId, PostTokenInput postTokenInput, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = postTokenInput;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/tokens"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesTokensPostValidateBeforeCall(UUID registryId, PostTokenInput postTokenInput, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesTokensPost(Async)");
        }
        
        // verify the required parameter 'postTokenInput' is set
        if (postTokenInput == null) {
            throw new ApiException("Missing the required parameter 'postTokenInput' when calling registriesTokensPost(Async)");
        }
        

        okhttp3.Call localVarCall = registriesTokensPostCall(registryId, postTokenInput, callback);
        return localVarCall;

    }

    /**
     * Create token
     * Create a token - password is only available once in the POST response
     * @param registryId The unique ID of the registry (required)
     * @param postTokenInput  (required)
     * 
     * @return PostTokenOutput
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public PostTokenOutput registriesTokensPost(UUID registryId, PostTokenInput postTokenInput) throws ApiException {
        ApiResponse<PostTokenOutput> localVarResp = registriesTokensPostWithHttpInfo(registryId, postTokenInput);
        return localVarResp.getData();
    }

    /**
     * Create token
     * Create a token - password is only available once in the POST response
     * @param registryId The unique ID of the registry (required)
     * @param postTokenInput  (required)
     * 
     * @return ApiResponse&lt;PostTokenOutput&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostTokenOutput> registriesTokensPostWithHttpInfo(UUID registryId, PostTokenInput postTokenInput) throws ApiException {
        okhttp3.Call localVarCall = registriesTokensPostValidateBeforeCall(registryId, postTokenInput, null);
        Type localVarReturnType = new TypeToken<PostTokenOutput>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create token (asynchronously)
     * Create a token - password is only available once in the POST response
     * @param registryId The unique ID of the registry (required)
     * @param postTokenInput  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensPostAsync(UUID registryId, PostTokenInput postTokenInput, final ApiCallback<PostTokenOutput> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesTokensPostValidateBeforeCall(registryId, postTokenInput, callback);
        Type localVarReturnType = new TypeToken<PostTokenOutput>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesTokensPut
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param putTokenInput  (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensPutCall(UUID registryId, String tokenId, PutTokenInput putTokenInput, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = putTokenInput;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/tokens/{tokenId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()))
            .replaceAll("\\{" + "tokenId" + "\\}", localVarApiClient.escapeString(tokenId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesTokensPutValidateBeforeCall(UUID registryId, String tokenId, PutTokenInput putTokenInput, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesTokensPut(Async)");
        }
        
        // verify the required parameter 'tokenId' is set
        if (tokenId == null) {
            throw new ApiException("Missing the required parameter 'tokenId' when calling registriesTokensPut(Async)");
        }
        
        // verify the required parameter 'putTokenInput' is set
        if (putTokenInput == null) {
            throw new ApiException("Missing the required parameter 'putTokenInput' when calling registriesTokensPut(Async)");
        }
        

        okhttp3.Call localVarCall = registriesTokensPutCall(registryId, tokenId, putTokenInput, callback);
        return localVarCall;

    }

    /**
     * Create or replace token
     * Create/replace a token - password is only available once in the create response - \&quot;name\&quot; cannot be changed
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param putTokenInput  (required)
     * 
     * @return PutTokenOutput
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public PutTokenOutput registriesTokensPut(UUID registryId, String tokenId, PutTokenInput putTokenInput) throws ApiException {
        ApiResponse<PutTokenOutput> localVarResp = registriesTokensPutWithHttpInfo(registryId, tokenId, putTokenInput);
        return localVarResp.getData();
    }

    /**
     * Create or replace token
     * Create/replace a token - password is only available once in the create response - \&quot;name\&quot; cannot be changed
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param putTokenInput  (required)
     * 
     * @return ApiResponse&lt;PutTokenOutput&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PutTokenOutput> registriesTokensPutWithHttpInfo(UUID registryId, String tokenId, PutTokenInput putTokenInput) throws ApiException {
        okhttp3.Call localVarCall = registriesTokensPutValidateBeforeCall(registryId, tokenId, putTokenInput, null);
        Type localVarReturnType = new TypeToken<PutTokenOutput>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create or replace token (asynchronously)
     * Create/replace a token - password is only available once in the create response - \&quot;name\&quot; cannot be changed
     * @param registryId The unique ID of the registry (required)
     * @param tokenId The unique ID of the token (required)
     * @param putTokenInput  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Created </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesTokensPutAsync(UUID registryId, String tokenId, PutTokenInput putTokenInput, final ApiCallback<PutTokenOutput> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesTokensPutValidateBeforeCall(registryId, tokenId, putTokenInput, callback);
        Type localVarReturnType = new TypeToken<PutTokenOutput>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
}
