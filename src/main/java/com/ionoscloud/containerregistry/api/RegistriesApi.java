/*
 * Container Registry service
 * Container Registry service enables IONOS clients to manage docker and OCI compliant registries for use by their managed Kubernetes clusters. Use a Container Registry to ensure you have a privately accessed registry to efficiently support image pulls.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ionoscloud.containerregistry.api;

import com.ionoscloud.containerregistry.ApiCallback;
import com.ionoscloud.containerregistry.ApiClient;
import com.ionoscloud.containerregistry.ApiException;
import com.ionoscloud.containerregistry.ApiResponse;
import com.ionoscloud.containerregistry.Configuration;
import com.ionoscloud.containerregistry.Pair;
import com.ionoscloud.containerregistry.ProgressRequestBody;
import com.ionoscloud.containerregistry.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.ionoscloud.containerregistry.model.ApiErrorResponse;
import com.ionoscloud.containerregistry.model.PatchRegistryInput;
import com.ionoscloud.containerregistry.model.PostRegistryInput;
import com.ionoscloud.containerregistry.model.PostRegistryOutput;
import com.ionoscloud.containerregistry.model.PutRegistryInput;
import com.ionoscloud.containerregistry.model.PutRegistryOutput;
import com.ionoscloud.containerregistry.model.RegistriesResponse;
import com.ionoscloud.containerregistry.model.RegistryResponse;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RegistriesApi {
    private ApiClient localVarApiClient;

    public RegistriesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RegistriesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for registriesDelete
     * @param registryId The unique ID of the registry (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesDeleteCall(UUID registryId, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesDeleteValidateBeforeCall(UUID registryId, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesDelete(Async)");
        }
        

        okhttp3.Call localVarCall = registriesDeleteCall(registryId, callback);
        return localVarCall;

    }

    /**
     * Delete registry
     * 
     * @param registryId The unique ID of the registry (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public void registriesDelete(UUID registryId) throws ApiException {
        registriesDeleteWithHttpInfo(registryId);
    }

    /**
     * Delete registry
     * 
     * @param registryId The unique ID of the registry (required)
     * 
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> registriesDeleteWithHttpInfo(UUID registryId) throws ApiException {
        okhttp3.Call localVarCall = registriesDeleteValidateBeforeCall(registryId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete registry (asynchronously)
     * 
     * @param registryId The unique ID of the registry (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesDeleteAsync(UUID registryId, final ApiCallback<Void> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesDeleteValidateBeforeCall(registryId, callback);
        localVarApiClient.executeAsync(localVarCall, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesFindById
     * @param registryId The unique ID of the registry (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesFindByIdCall(UUID registryId, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesFindByIdValidateBeforeCall(UUID registryId, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesFindById(Async)");
        }
        

        okhttp3.Call localVarCall = registriesFindByIdCall(registryId, callback);
        return localVarCall;

    }

    /**
     * Get a registry
     * Get all information for a specific container registry
     * @param registryId The unique ID of the registry (required)
     * 
     * @return RegistryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public RegistryResponse registriesFindById(UUID registryId) throws ApiException {
        ApiResponse<RegistryResponse> localVarResp = registriesFindByIdWithHttpInfo(registryId);
        return localVarResp.getData();
    }

    /**
     * Get a registry
     * Get all information for a specific container registry
     * @param registryId The unique ID of the registry (required)
     * 
     * @return ApiResponse&lt;RegistryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RegistryResponse> registriesFindByIdWithHttpInfo(UUID registryId) throws ApiException {
        okhttp3.Call localVarCall = registriesFindByIdValidateBeforeCall(registryId, null);
        Type localVarReturnType = new TypeToken<RegistryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a registry (asynchronously)
     * Get all information for a specific container registry
     * @param registryId The unique ID of the registry (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesFindByIdAsync(UUID registryId, final ApiCallback<RegistryResponse> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesFindByIdValidateBeforeCall(registryId, callback);
        Type localVarReturnType = new TypeToken<RegistryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesGet
     * @param filterName The registry name to search for (optional)
     * @param limit The maximum number of elements to return (used together with pagination.token for pagination) (optional, default to 100)
     * @param paginationToken An opaque token used to iterate the set of results (used together with limit for pagination) (optional)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesGetCall(String filterName, String limit, String paginationToken,  String orderBy, Integer maxResults, Map<String, String> filters,final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filterName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter.name", filterName));
        }
        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }
        if (paginationToken != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagination.token", paginationToken));
        }
        if (orderBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderBy", orderBy));
        }
        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }
        if (filters != null) {
            filters.forEach((key, value) -> {
                localVarQueryParams.add(new Pair(String.format("filter.%s", key), value));
            });
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesGetValidateBeforeCall(String filterName, String limit, String paginationToken,  String orderBy, Integer maxResults , Map<String, String> filters,final ApiCallback callback) throws ApiException {
        

        okhttp3.Call localVarCall = registriesGetCall(filterName, limit, paginationToken,  orderBy, maxResults, filters,callback);
        return localVarCall;

    }

    /**
     * List all container registries
     * List all managed container registries for your account
     * @param filterName The registry name to search for (optional)
     * @param limit The maximum number of elements to return (used together with pagination.token for pagination) (optional, default to 100)
     * @param paginationToken An opaque token used to iterate the set of results (used together with limit for pagination) (optional)
     * @param orderBy - Sorts the results alphanumerically in ascending order based on the specified property.
     * @param maxResults - Limits the number of results returned.
     * @param filters - Filters query parameters limit results to those containing a matching value for a specific property.
     * @return RegistriesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RegistriesResponse registriesGet(String filterName, String limit, String paginationToken,  String orderBy, Integer maxResults, Map<String, String> filters) throws ApiException {
        ApiResponse<RegistriesResponse> localVarResp = registriesGetWithHttpInfo(filterName, limit, paginationToken, orderBy, maxResults, filters);
        return localVarResp.getData();
    }

    /**
     * List all container registries
     * List all managed container registries for your account
     * @param filterName The registry name to search for (optional)
     * @param limit The maximum number of elements to return (used together with pagination.token for pagination) (optional, default to 100)
     * @param paginationToken An opaque token used to iterate the set of results (used together with limit for pagination) (optional)
     * @param orderBy - Sorts the results alphanumerically in ascending order based on the specified property.
     * @param maxResults - Limits the number of results returned.
     * @param filters - Filters query parameters limit results to those containing a matching value for a specific property.
     * @return ApiResponse&lt;RegistriesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RegistriesResponse> registriesGetWithHttpInfo(String filterName, String limit, String paginationToken, String orderBy, Integer maxResults, Map<String, String> filters) throws ApiException {
        okhttp3.Call localVarCall = registriesGetValidateBeforeCall(filterName, limit, paginationToken,  orderBy, maxResults, filters, null);
        Type localVarReturnType = new TypeToken<RegistriesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all container registries (asynchronously)
     * List all managed container registries for your account
     * @param filterName The registry name to search for (optional)
     * @param limit The maximum number of elements to return (used together with pagination.token for pagination) (optional, default to 100)
     * @param paginationToken An opaque token used to iterate the set of results (used together with limit for pagination) (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesGetAsync(String filterName, String limit, String paginationToken, String orderBy, Integer maxResults, Map<String, String> filters,final ApiCallback<RegistriesResponse> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesGetValidateBeforeCall(filterName, limit, paginationToken,  orderBy, maxResults, filters, callback);
        Type localVarReturnType = new TypeToken<RegistriesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesPatch
     * @param registryId The unique ID of the registry (required)
     * @param patchRegistryInput  (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesPatchCall(UUID registryId, PatchRegistryInput patchRegistryInput, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = patchRegistryInput;

        // create path and map variables
        String localVarPath = "/registries/{registryId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesPatchValidateBeforeCall(UUID registryId, PatchRegistryInput patchRegistryInput, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesPatch(Async)");
        }
        
        // verify the required parameter 'patchRegistryInput' is set
        if (patchRegistryInput == null) {
            throw new ApiException("Missing the required parameter 'patchRegistryInput' when calling registriesPatch(Async)");
        }
        

        okhttp3.Call localVarCall = registriesPatchCall(registryId, patchRegistryInput, callback);
        return localVarCall;

    }

    /**
     * Update the properties of a registry
     * Update the properties of a registry - \&quot;garbageCollectionSchedule\&quot; time and days of the week for runs
     * @param registryId The unique ID of the registry (required)
     * @param patchRegistryInput  (required)
     * 
     * @return RegistryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RegistryResponse registriesPatch(UUID registryId, PatchRegistryInput patchRegistryInput) throws ApiException {
        ApiResponse<RegistryResponse> localVarResp = registriesPatchWithHttpInfo(registryId, patchRegistryInput);
        return localVarResp.getData();
    }

    /**
     * Update the properties of a registry
     * Update the properties of a registry - \&quot;garbageCollectionSchedule\&quot; time and days of the week for runs
     * @param registryId The unique ID of the registry (required)
     * @param patchRegistryInput  (required)
     * 
     * @return ApiResponse&lt;RegistryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RegistryResponse> registriesPatchWithHttpInfo(UUID registryId, PatchRegistryInput patchRegistryInput) throws ApiException {
        okhttp3.Call localVarCall = registriesPatchValidateBeforeCall(registryId, patchRegistryInput, null);
        Type localVarReturnType = new TypeToken<RegistryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update the properties of a registry (asynchronously)
     * Update the properties of a registry - \&quot;garbageCollectionSchedule\&quot; time and days of the week for runs
     * @param registryId The unique ID of the registry (required)
     * @param patchRegistryInput  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesPatchAsync(UUID registryId, PatchRegistryInput patchRegistryInput, final ApiCallback<RegistryResponse> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesPatchValidateBeforeCall(registryId, patchRegistryInput, callback);
        Type localVarReturnType = new TypeToken<RegistryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesPost
     * @param postRegistryInput  (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesPostCall(PostRegistryInput postRegistryInput, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = postRegistryInput;

        // create path and map variables
        String localVarPath = "/registries";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesPostValidateBeforeCall(PostRegistryInput postRegistryInput, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'postRegistryInput' is set
        if (postRegistryInput == null) {
            throw new ApiException("Missing the required parameter 'postRegistryInput' when calling registriesPost(Async)");
        }
        

        okhttp3.Call localVarCall = registriesPostCall(postRegistryInput, callback);
        return localVarCall;

    }

    /**
     * Create container registry
     * Create a registry to hold container images or OCI compliant artifacts - \&quot;name\&quot; must have passed validation - \&quot;location\&quot; must be one of the available location IDs - \&quot;garbageCollectionSchedule\&quot; time and days of the week for runs
     * @param postRegistryInput  (required)
     * 
     * @return PostRegistryOutput
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public PostRegistryOutput registriesPost(PostRegistryInput postRegistryInput) throws ApiException {
        ApiResponse<PostRegistryOutput> localVarResp = registriesPostWithHttpInfo(postRegistryInput);
        return localVarResp.getData();
    }

    /**
     * Create container registry
     * Create a registry to hold container images or OCI compliant artifacts - \&quot;name\&quot; must have passed validation - \&quot;location\&quot; must be one of the available location IDs - \&quot;garbageCollectionSchedule\&quot; time and days of the week for runs
     * @param postRegistryInput  (required)
     * 
     * @return ApiResponse&lt;PostRegistryOutput&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PostRegistryOutput> registriesPostWithHttpInfo(PostRegistryInput postRegistryInput) throws ApiException {
        okhttp3.Call localVarCall = registriesPostValidateBeforeCall(postRegistryInput, null);
        Type localVarReturnType = new TypeToken<PostRegistryOutput>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create container registry (asynchronously)
     * Create a registry to hold container images or OCI compliant artifacts - \&quot;name\&quot; must have passed validation - \&quot;location\&quot; must be one of the available location IDs - \&quot;garbageCollectionSchedule\&quot; time and days of the week for runs
     * @param postRegistryInput  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesPostAsync(PostRegistryInput postRegistryInput, final ApiCallback<PostRegistryOutput> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesPostValidateBeforeCall(postRegistryInput, callback);
        Type localVarReturnType = new TypeToken<PostRegistryOutput>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
    /**
     * Build call for registriesPut
     * @param registryId The unique ID of the registry (required)
     * @param putRegistryInput  (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesPutCall(UUID registryId, PutRegistryInput putRegistryInput, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = putRegistryInput;

        // create path and map variables
        String localVarPath = "/registries/{registryId}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesPutValidateBeforeCall(UUID registryId, PutRegistryInput putRegistryInput, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesPut(Async)");
        }
        
        // verify the required parameter 'putRegistryInput' is set
        if (putRegistryInput == null) {
            throw new ApiException("Missing the required parameter 'putRegistryInput' when calling registriesPut(Async)");
        }
        

        okhttp3.Call localVarCall = registriesPutCall(registryId, putRegistryInput, callback);
        return localVarCall;

    }

    /**
     * Create or replace a container registry
     * Create/replace a registry to hold container images or OCI compliant artifacts  **On create** - \&quot;name\&quot; must have passed validation - \&quot;location\&quot; must be one of the available location IDs  **On update** - \&quot;name\&quot; cannot be changed - \&quot;location\&quot; cannot be changed  **On create or update** - \&quot;garbageCollectionSchedule\&quot;: time and days of the week for runs 
     * @param registryId The unique ID of the registry (required)
     * @param putRegistryInput  (required)
     * 
     * @return PutRegistryOutput
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public PutRegistryOutput registriesPut(UUID registryId, PutRegistryInput putRegistryInput) throws ApiException {
        ApiResponse<PutRegistryOutput> localVarResp = registriesPutWithHttpInfo(registryId, putRegistryInput);
        return localVarResp.getData();
    }

    /**
     * Create or replace a container registry
     * Create/replace a registry to hold container images or OCI compliant artifacts  **On create** - \&quot;name\&quot; must have passed validation - \&quot;location\&quot; must be one of the available location IDs  **On update** - \&quot;name\&quot; cannot be changed - \&quot;location\&quot; cannot be changed  **On create or update** - \&quot;garbageCollectionSchedule\&quot;: time and days of the week for runs 
     * @param registryId The unique ID of the registry (required)
     * @param putRegistryInput  (required)
     * 
     * @return ApiResponse&lt;PutRegistryOutput&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PutRegistryOutput> registriesPutWithHttpInfo(UUID registryId, PutRegistryInput putRegistryInput) throws ApiException {
        okhttp3.Call localVarCall = registriesPutValidateBeforeCall(registryId, putRegistryInput, null);
        Type localVarReturnType = new TypeToken<PutRegistryOutput>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create or replace a container registry (asynchronously)
     * Create/replace a registry to hold container images or OCI compliant artifacts  **On create** - \&quot;name\&quot; must have passed validation - \&quot;location\&quot; must be one of the available location IDs  **On update** - \&quot;name\&quot; cannot be changed - \&quot;location\&quot; cannot be changed  **On create or update** - \&quot;garbageCollectionSchedule\&quot;: time and days of the week for runs 
     * @param registryId The unique ID of the registry (required)
     * @param putRegistryInput  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> The created container registry is returned with &#39;metadata.status&#39; set to \&quot;BUSY\&quot;. </td><td>  * Location -  <br>  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesPutAsync(UUID registryId, PutRegistryInput putRegistryInput, final ApiCallback<PutRegistryOutput> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesPutValidateBeforeCall(registryId, putRegistryInput, callback);
        Type localVarReturnType = new TypeToken<PutRegistryOutput>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, callback);
        return localVarCall;
    }
}
