/*
 * Container Registry service
 * Container Registry service enables IONOS clients to manage docker and OCI compliant registries for use by their managed Kubernetes clusters. Use a Container Registry to ensure you have a privately accessed registry to efficiently support image pulls.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ionoscloud.containerregistry.api;

import com.ionoscloud.containerregistry.ApiCallback;
import com.ionoscloud.containerregistry.ApiClient;
import com.ionoscloud.containerregistry.ApiException;
import com.ionoscloud.containerregistry.ApiResponse;
import com.ionoscloud.containerregistry.Configuration;
import com.ionoscloud.containerregistry.Pair;
import com.ionoscloud.containerregistry.ProgressRequestBody;
import com.ionoscloud.containerregistry.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RepositoriesApi {
    private ApiClient localVarApiClient;

    public RepositoriesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RepositoriesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for registriesRepositoriesDelete
     * @param registryId The unique ID of the registry (required)
     * @param name The name of the repository (required)
     * @param callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesDeleteCall(UUID registryId, String name, final ApiCallback callback ) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/repositories/{name}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()))
            .replaceAll("\\{" + "name" + "\\}", localVarApiClient.escapeString(name.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();


        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesRepositoriesDeleteValidateBeforeCall(UUID registryId, String name, final ApiCallback callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesRepositoriesDelete(Async)");
        }
        
        // verify the required parameter 'name' is set
        if (name == null) {
            throw new ApiException("Missing the required parameter 'name' when calling registriesRepositoriesDelete(Async)");
        }
        

        okhttp3.Call localVarCall = registriesRepositoriesDeleteCall(registryId, name, callback);
        return localVarCall;

    }

    /**
     * Delete repository
     * Delete all repository contents    The registry V2 API allows manifests and blobs to be deleted individually but it is not possible to remove an entire repository.   This operation is provided for convenience
     * @param registryId The unique ID of the registry (required)
     * @param name The name of the repository (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void registriesRepositoriesDelete(UUID registryId, String name) throws ApiException {
        registriesRepositoriesDeleteWithHttpInfo(registryId, name);
    }

    /**
     * Delete repository
     * Delete all repository contents    The registry V2 API allows manifests and blobs to be deleted individually but it is not possible to remove an entire repository.   This operation is provided for convenience
     * @param registryId The unique ID of the registry (required)
     * @param name The name of the repository (required)
     * 
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> registriesRepositoriesDeleteWithHttpInfo(UUID registryId, String name) throws ApiException {
        okhttp3.Call localVarCall = registriesRepositoriesDeleteValidateBeforeCall(registryId, name, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete repository (asynchronously)
     * Delete all repository contents    The registry V2 API allows manifests and blobs to be deleted individually but it is not possible to remove an entire repository.   This operation is provided for convenience
     * @param registryId The unique ID of the registry (required)
     * @param name The name of the repository (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesDeleteAsync(UUID registryId, String name, final ApiCallback<Void> callback) throws ApiException {

        okhttp3.Call localVarCall = registriesRepositoriesDeleteValidateBeforeCall(registryId, name, callback);
        localVarApiClient.executeAsync(localVarCall, callback);
        return localVarCall;
    }
}
