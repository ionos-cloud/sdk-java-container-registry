/*
 * Container Registry service
 * ## Overview Container Registry service enables IONOS clients to manage docker and OCI compliant registries for use by their managed Kubernetes clusters. Use a Container Registry to ensure you have a privately accessed registry to efficiently support image pulls. ## Changelog ### 1.1.0  - Added new endpoints for Repositories  - Added new endpoints for Artifacts  - Added new endpoints for Vulnerabilities  - Added registry vulnerabilityScanning feature 
 *
 * The version of the OpenAPI document: 1.1.0
 * Contact: support@cloud.ionos.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.ionoscloud.containerregistry.api;

import com.ionoscloud.containerregistry.ApiCallback;
import com.ionoscloud.containerregistry.ApiClient;
import com.ionoscloud.containerregistry.ApiException;
import com.ionoscloud.containerregistry.ApiResponse;
import com.ionoscloud.containerregistry.Configuration;
import com.ionoscloud.containerregistry.Pair;
import com.ionoscloud.containerregistry.ProgressRequestBody;
import com.ionoscloud.containerregistry.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.ionoscloud.containerregistry.model.Error;
import com.ionoscloud.containerregistry.model.RepositoryRead;
import com.ionoscloud.containerregistry.model.RepositoryReadList;
import java.util.UUID;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RepositoriesApi {
    private ApiClient localVarApiClient;

    public RepositoriesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RepositoriesApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for registriesRepositoriesDelete
     * @param registryId The unique ID of the registry (required)
     * @param repositoryName The name of the repository (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesDeleteCall(UUID registryId, String repositoryName, final ApiCallback<Void> _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/repositories/{repositoryName}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()))
            .replaceAll("\\{" + "repositoryName" + "\\}", localVarApiClient.escapeString(repositoryName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesRepositoriesDeleteValidateBeforeCall(UUID registryId, String repositoryName, final ApiCallback<Void> _callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesRepositoriesDelete(Async)");
        }
        
        // verify the required parameter 'repositoryName' is set
        if (repositoryName == null) {
            throw new ApiException("Missing the required parameter 'repositoryName' when calling registriesRepositoriesDelete(Async)");
        }
        

        okhttp3.Call localVarCall = registriesRepositoriesDeleteCall(registryId, repositoryName, _callback);
        return localVarCall;

    }

    /**
     * Delete repository
     * Delete all repository contents    The registry V2 API allows manifests and blobs to be deleted individually but it is not possible to remove an entire repository.   This operation is provided for convenience
     * @param registryId The unique ID of the registry (required)
     * @param repositoryName The name of the repository (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void registriesRepositoriesDelete(UUID registryId, String repositoryName) throws ApiException {
        registriesRepositoriesDeleteWithHttpInfo(registryId, repositoryName);
    }

    /**
     * Delete repository
     * Delete all repository contents    The registry V2 API allows manifests and blobs to be deleted individually but it is not possible to remove an entire repository.   This operation is provided for convenience
     * @param registryId The unique ID of the registry (required)
     * @param repositoryName The name of the repository (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> registriesRepositoriesDeleteWithHttpInfo(UUID registryId, String repositoryName) throws ApiException {
        okhttp3.Call localVarCall = registriesRepositoriesDeleteValidateBeforeCall(registryId, repositoryName, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete repository (asynchronously)
     * Delete all repository contents    The registry V2 API allows manifests and blobs to be deleted individually but it is not possible to remove an entire repository.   This operation is provided for convenience
     * @param registryId The unique ID of the registry (required)
     * @param repositoryName The name of the repository (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesDeleteAsync(UUID registryId, String repositoryName, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = registriesRepositoriesDeleteValidateBeforeCall(registryId, repositoryName, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for registriesRepositoriesFindByName
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param repositoryName The Name of the Repository that should be retrieved. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Getting Repository was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> ### Not Found The resource that was requested could not be found.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesFindByNameCall(UUID registryId, String repositoryName, final ApiCallback<RepositoryRead> _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/repositories/{repositoryName}"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()))
            .replaceAll("\\{" + "repositoryName" + "\\}", localVarApiClient.escapeString(repositoryName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesRepositoriesFindByNameValidateBeforeCall(UUID registryId, String repositoryName, final ApiCallback<RepositoryRead> _callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesRepositoriesFindByName(Async)");
        }
        
        // verify the required parameter 'repositoryName' is set
        if (repositoryName == null) {
            throw new ApiException("Missing the required parameter 'repositoryName' when calling registriesRepositoriesFindByName(Async)");
        }
        

        okhttp3.Call localVarCall = registriesRepositoriesFindByNameCall(registryId, repositoryName, _callback);
        return localVarCall;

    }

    /**
     * Retrieve Repository
     * Returns the Repository by Name.
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param repositoryName The Name of the Repository that should be retrieved. (required)
     * @return RepositoryRead
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Getting Repository was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> ### Not Found The resource that was requested could not be found.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public RepositoryRead registriesRepositoriesFindByName(UUID registryId, String repositoryName) throws ApiException {
        ApiResponse<RepositoryRead> localVarResp = registriesRepositoriesFindByNameWithHttpInfo(registryId, repositoryName);
        return localVarResp.getData();
    }

    /**
     * Retrieve Repository
     * Returns the Repository by Name.
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param repositoryName The Name of the Repository that should be retrieved. (required)
     * @return ApiResponse&lt;RepositoryRead&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Getting Repository was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> ### Not Found The resource that was requested could not be found.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RepositoryRead> registriesRepositoriesFindByNameWithHttpInfo(UUID registryId, String repositoryName) throws ApiException {
        okhttp3.Call localVarCall = registriesRepositoriesFindByNameValidateBeforeCall(registryId, repositoryName, null);
        Type localVarReturnType = new TypeToken<RepositoryRead>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve Repository (asynchronously)
     * Returns the Repository by Name.
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param repositoryName The Name of the Repository that should be retrieved. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Getting Repository was successful. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> ### Not Found The resource that was requested could not be found.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesFindByNameAsync(UUID registryId, String repositoryName, final ApiCallback<RepositoryRead> _callback) throws ApiException {

        okhttp3.Call localVarCall = registriesRepositoriesFindByNameValidateBeforeCall(registryId, repositoryName, _callback);
        Type localVarReturnType = new TypeToken<RepositoryRead>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for registriesRepositoriesGet
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param offset The first element (of the total list of elements) to include in the response. Use together with limit for pagination. (optional, default to 0)
     * @param limit The maximum number of elements to return. Use together with offset for pagination. (optional, default to 100)
     * @param filterName Filter resources by name. (optional)
     * @param filterVulnerabilitySeverity Filter resources by vulnerability severity. (optional)
     * @param orderBy The field to order the results by. If not provided, the results will be ordered by the default field. (optional, default to -lastPush)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned all requested Repositories successfully.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesGetCall(UUID registryId, Integer offset, Integer limit, String filterName, String filterVulnerabilitySeverity, String orderBy, final ApiCallback<RepositoryReadList> _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/registries/{registryId}/repositories"
            .replaceAll("\\{" + "registryId" + "\\}", localVarApiClient.escapeString(registryId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (filterName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter.name", filterName));
        }

        if (filterVulnerabilitySeverity != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter.vulnerabilitySeverity", filterVulnerabilitySeverity));
        }

        if (orderBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderBy", orderBy));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "tokenAuth" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call registriesRepositoriesGetValidateBeforeCall(UUID registryId, Integer offset, Integer limit, String filterName, String filterVulnerabilitySeverity, String orderBy, final ApiCallback<RepositoryReadList> _callback) throws ApiException {
        
        // verify the required parameter 'registryId' is set
        if (registryId == null) {
            throw new ApiException("Missing the required parameter 'registryId' when calling registriesRepositoriesGet(Async)");
        }
        

        okhttp3.Call localVarCall = registriesRepositoriesGetCall(registryId, offset, limit, filterName, filterVulnerabilitySeverity, orderBy, _callback);
        return localVarCall;

    }

    /**
     * Retrieve all Repositories
     * This endpoint enables retrieving all Repositories using pagination and optional filters. 
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param offset The first element (of the total list of elements) to include in the response. Use together with limit for pagination. (optional, default to 0)
     * @param limit The maximum number of elements to return. Use together with offset for pagination. (optional, default to 100)
     * @param filterName Filter resources by name. (optional)
     * @param filterVulnerabilitySeverity Filter resources by vulnerability severity. (optional)
     * @param orderBy The field to order the results by. If not provided, the results will be ordered by the default field. (optional, default to -lastPush)
     * @return RepositoryReadList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned all requested Repositories successfully.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public RepositoryReadList registriesRepositoriesGet(UUID registryId, Integer offset, Integer limit, String filterName, String filterVulnerabilitySeverity, String orderBy) throws ApiException {
        ApiResponse<RepositoryReadList> localVarResp = registriesRepositoriesGetWithHttpInfo(registryId, offset, limit, filterName, filterVulnerabilitySeverity, orderBy);
        return localVarResp.getData();
    }

    /**
     * Retrieve all Repositories
     * This endpoint enables retrieving all Repositories using pagination and optional filters. 
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param offset The first element (of the total list of elements) to include in the response. Use together with limit for pagination. (optional, default to 0)
     * @param limit The maximum number of elements to return. Use together with offset for pagination. (optional, default to 100)
     * @param filterName Filter resources by name. (optional)
     * @param filterVulnerabilitySeverity Filter resources by vulnerability severity. (optional)
     * @param orderBy The field to order the results by. If not provided, the results will be ordered by the default field. (optional, default to -lastPush)
     * @return ApiResponse&lt;RepositoryReadList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned all requested Repositories successfully.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RepositoryReadList> registriesRepositoriesGetWithHttpInfo(UUID registryId, Integer offset, Integer limit, String filterName, String filterVulnerabilitySeverity, String orderBy) throws ApiException {
        okhttp3.Call localVarCall = registriesRepositoriesGetValidateBeforeCall(registryId, offset, limit, filterName, filterVulnerabilitySeverity, orderBy, null);
        Type localVarReturnType = new TypeToken<RepositoryReadList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve all Repositories (asynchronously)
     * This endpoint enables retrieving all Repositories using pagination and optional filters. 
     * @param registryId The ID (UUID) of the Registry. (required)
     * @param offset The first element (of the total list of elements) to include in the response. Use together with limit for pagination. (optional, default to 0)
     * @param limit The maximum number of elements to return. Use together with offset for pagination. (optional, default to 100)
     * @param filterName Filter resources by name. (optional)
     * @param filterVulnerabilitySeverity Filter resources by vulnerability severity. (optional)
     * @param orderBy The field to order the results by. If not provided, the results will be ordered by the default field. (optional, default to -lastPush)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returned all requested Repositories successfully.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> ### Bad Request The request send to the API was malformed.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> ### Unauthorized The request is missing authorization information or the authorization information provided are expired.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> ### Internal Server Error An internal error occurred. We apologize for the inconvenience!  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call registriesRepositoriesGetAsync(UUID registryId, Integer offset, Integer limit, String filterName, String filterVulnerabilitySeverity, String orderBy, final ApiCallback<RepositoryReadList> _callback) throws ApiException {

        okhttp3.Call localVarCall = registriesRepositoriesGetValidateBeforeCall(registryId, offset, limit, filterName, filterVulnerabilitySeverity, orderBy, _callback);
        Type localVarReturnType = new TypeToken<RepositoryReadList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
